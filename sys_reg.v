// Filename          : sys_reg.v.v
// Author            : rafter_soc
// Created           : 2025-03-19 18:00:42
// Description       : This file is auto generated by gen_reg.py script. Not edit by hand
//                   : addr_width = 12
//                   : bus_type   = regbus
//                   : base_addr  = 32'h0000

module sys_reg (
input               clk,
input               rst_n,
input       [11:0]  reg_addr,
input               wr_en,
input               rd_en,
input       [3 :0]  wr_msk,
input       [31:0]  wr_data,
output reg  [31:0]  rd_data,
output reg  [02:0]  tl_pm_bwchange_speed,
output reg          tl_pm_bwchange_speed_en,
output reg          tl_int_status,
output reg          tl_cor,
output reg          tl_uncor,
input               adapt_reset_intr_sts_hw_en,
input               adapt_reset_intr_sts_hw_val,
output reg          adapt_reset_intr_sts,
input               local_int_out_sts_hw_en,
input               local_int_out_sts_hw_val,
output reg          local_int_out_sts,
input               slv1_wr_pf_pending,
input       [15:0]  ltssm_time[63:0],
input       [06:0]  ltssm_state[63:0],
output reg  [31:0]  k_phyparam[4:0],
output reg  [16:0]  test_2[2:0],
output reg  [12:0]  test_1[2:0]
);

//============================================================================
// reg and wire declaration
//============================================================================
reg  [31:0]    rd_data_nxt ;
wire [31:0]    msk;
wire           wr_en_PCIE_CTRL0;
wire           wr_en_PCIE_CTRL2;
wire           wr_en_PCIE_ERR_CTRL;
wire           wr_en_PCIE_INT_STS;
reg  [31:0]    rd_data_nxt_PCIE_LTSSM_STS0;
reg  [31:0]    rd_data_nxt_PCIE_K_PHYPARAM;
wire           wr_en_PCIE_K_PHYPARAM[4:0];
reg  [31:0]    rd_data_nxt_PCIE_TEST;
wire           wr_en_PCIE_TEST[2:0];
//============================================================================
//main code
//============================================================================
assign msk = {{8{wr_msk[3]}},{8{wr_msk[2]}},{8{wr_msk[1]}},{8{wr_msk[0]}}};

//============================================================================
// reg wr_en/rd_en assignment
//============================================================================
assign wr_en_PCIE_CTRL0         = wr_en & (reg_addr[11:0] == 12'h0);
assign wr_en_PCIE_CTRL2         = wr_en & (reg_addr[11:0] == 12'h8);
assign wr_en_PCIE_ERR_CTRL      = wr_en & (reg_addr[11:0] == 12'hc);
assign wr_en_PCIE_INT_STS       = wr_en & (reg_addr[11:0] == 12'h14);

genvar i;
generate
    for(i = 0; i <= 4; i = i + 1) begin: wr_PCIE_K_PHYPARAM
        assign wr_en_PCIE_K_PHYPARAM[i]= wr_en & (reg_addr[11:0] == 12'ha80 + 12'h4 * i );
    end
endgenerate
generate
    for(i = 0; i <= 2; i = i + 1) begin: wr_PCIE_TEST
        assign wr_en_PCIE_TEST[i]= wr_en & (reg_addr[11:0] == 12'hb80 + 12'h4 * i );
    end
endgenerate

//============================================================================
// reg write
//============================================================================
//============================================================================
// tl_pm_bwchange_speed addr:12'h0 type:RW bits:[27:25] default:3'h0
//============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        tl_pm_bwchange_speed[2:0] <= 3'h0;
    else begin
        if (wr_en_PCIE_CTRL0 == 1'b1)
            tl_pm_bwchange_speed[2:0] <= (tl_pm_bwchange_speed[2:0] & ~msk[27:25]) | (wr_data[27:25] & msk[27:25]);
    end
end

//============================================================================
// tl_pm_bwchange_speed_en addr:12'h0 type:W1P bits:[24] default:1'b0
//============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        tl_pm_bwchange_speed_en <= 1'b0;
    else begin
        if (wr_en_PCIE_CTRL0 == 1'b1)
            tl_pm_bwchange_speed_en <= wr_data[24] & msk[24];
        else
            tl_pm_bwchange_speed_en <= 1'b0;
    end
end

//============================================================================
// tl_int_status addr:12'h8 type:RW bits:[0] default:1'b0
//============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        tl_int_status <= 1'b0;
    else begin
        if (wr_en_PCIE_CTRL2 == 1'b1)
            tl_int_status <= (tl_int_status & ~msk[0]) | (wr_data[0] & msk[0]);
    end
end

//============================================================================
// tl_cor addr:12'hc type:W1P bits:[1] default:1'b0
//============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        tl_cor <= 1'b0;
    else begin
        if (wr_en_PCIE_ERR_CTRL == 1'b1)
            tl_cor <= wr_data[1] & msk[1];
        else
            tl_cor <= 1'b0;
    end
end

//============================================================================
// tl_uncor addr:12'hc type:W1P bits:[0] default:1'b0
//============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        tl_uncor <= 1'b0;
    else begin
        if (wr_en_PCIE_ERR_CTRL == 1'b1)
            tl_uncor <= wr_data[0] & msk[0];
        else
            tl_uncor <= 1'b0;
    end
end

//============================================================================
// adapt_reset_intr_sts addr:12'h14 type:W1C bits:[16] default:1'b0
//============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        adapt_reset_intr_sts <= 1'b0;
    else begin
        if (adapt_reset_intr_sts_hw_en == 1'b1)
            adapt_reset_intr_sts <= adapt_reset_intr_sts_hw_val;
        else if (wr_en_PCIE_INT_STS == 1'b1)
            adapt_reset_intr_sts <= (~wr_data[16] | ~msk[16]) & adapt_reset_intr_sts;
    end
end

//============================================================================
// local_int_out_sts addr:12'h14 type:W1C bits:[15] default:1'b0
//============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        local_int_out_sts <= 1'b0;
    else begin
        if (local_int_out_sts_hw_en == 1'b1)
            local_int_out_sts <= local_int_out_sts_hw_val;
        else if (wr_en_PCIE_INT_STS == 1'b1)
            local_int_out_sts <= (~wr_data[15] | ~msk[15]) & local_int_out_sts;
    end
end

//============================================================================
// rd_data_nxt_PCIE_LTSSM_STS0
//============================================================================
integer j;
always @(*) begin
    rd_data_nxt_PCIE_LTSSM_STS0[31:0]  = 32'h0;
    for(j = 0; j <= 63; j = j + 1) begin:rdata_loop_PCIE_LTSSM_STS0
        if (reg_addr[11:0] == 12'h100 + 12'h8 * j) begin
            rd_data_nxt_PCIE_LTSSM_STS0[31:16] = ltssm_time[j][15:0];
            rd_data_nxt_PCIE_LTSSM_STS0[6:0] = ltssm_state[j][6:0];
        end
    end
end

//============================================================================
// k_phyparam addr:12'ha80 type:RW bits:[31:0] default:32'h0
//============================================================================
generate
    for(i = 0; i <= 4; i = i + 1) begin: wr_k_phyparam
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n)
                k_phyparam[i] <= 32'h0;
            else begin
                if (wr_en_PCIE_K_PHYPARAM[i] == 1'b1)
                    k_phyparam[i][31:0] <= (k_phyparam[i][31:0] & ~msk[31:0]) | (wr_data[31:0] & msk[31:0]);
            end
        end
    end
endgenerate
//============================================================================
// rd_data_nxt_PCIE_K_PHYPARAM
//============================================================================
always @(*) begin
    rd_data_nxt_PCIE_K_PHYPARAM[31:0]  = 32'h0;
    for(j = 0; j <= 4; j = j + 1) begin:rdata_loop_PCIE_K_PHYPARAM
        if (reg_addr[11:0] == 12'ha80 + 12'h4 * j) begin
            rd_data_nxt_PCIE_K_PHYPARAM[31:0] = k_phyparam[j][31:0];
        end
    end
end

//============================================================================
// test_2 addr:12'hb80 type:RW bits:[31:15] default:17'h0
//============================================================================
generate
    for(i = 0; i <= 2; i = i + 1) begin: wr_test_2
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n)
                test_2[i] <= 17'h0;
            else begin
                if (wr_en_PCIE_TEST[i] == 1'b1)
                    test_2[i][16:0] <= (test_2[i][16:0] & ~msk[31:15]) | (wr_data[31:15] & msk[31:15]);
            end
        end
    end
endgenerate
//============================================================================
// test_1 addr:12'hb80 type:RW bits:[12:0] default:13'h0
//============================================================================
generate
    for(i = 0; i <= 2; i = i + 1) begin: wr_test_1
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n)
                test_1[i] <= 13'h0;
            else begin
                if (wr_en_PCIE_TEST[i] == 1'b1)
                    test_1[i][12:0] <= (test_1[i][12:0] & ~msk[12:0]) | (wr_data[12:0] & msk[12:0]);
            end
        end
    end
endgenerate
//============================================================================
// rd_data_nxt_PCIE_TEST
//============================================================================
always @(*) begin
    rd_data_nxt_PCIE_TEST[31:0]  = 32'h0;
    for(j = 0; j <= 2; j = j + 1) begin:rdata_loop_PCIE_TEST
        if (reg_addr[11:0] == 12'hb80 + 12'h4 * j) begin
            rd_data_nxt_PCIE_TEST[31:15] = test_2[j][16:0];
            rd_data_nxt_PCIE_TEST[12:0] = test_1[j][12:0];
        end
    end
end

//============================================================================
// next read data
//============================================================================
always @(*) begin
    rd_data_nxt[31:0] = 32'h0;
    case(reg_addr[11:0])
    12'h0: begin
        rd_data_nxt[27:25] = tl_pm_bwchange_speed[2:0];
        rd_data_nxt[24] = 1'h0;
    end
    12'h8: begin
        rd_data_nxt[0] = tl_int_status;
    end
    12'hc: begin
        rd_data_nxt[1] = 1'h0;
        rd_data_nxt[0] = 1'h0;
    end
    12'h14: begin
        rd_data_nxt[16] = adapt_reset_intr_sts;
        rd_data_nxt[15] = local_int_out_sts;
    end
    12'h24: begin
        rd_data_nxt[6] = slv1_wr_pf_pending;
    end
    default: 
        rd_data_nxt = rd_data_nxt_PCIE_LTSSM_STS0 | rd_data_nxt_PCIE_K_PHYPARAM | rd_data_nxt_PCIE_TEST;
    endcase
end

//============================================================================
// read data
//============================================================================
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        rd_data[31:0] <= 32'h0; 
    else if(rd_en)
        rd_data[31:0] <= rd_data_nxt[31:0];
end

endmodule